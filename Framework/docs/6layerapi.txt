SixLayer Framework API Reference

## Current API Functions (v2.6.0+)

### Layer 1 Semantic Functions (PlatformSemanticLayer1.swift)
- `platformPresentItemCollection_L1<Item: Identifiable>(items: [Item], hints: PresentationHints, onCreateItem: (() -> Void)? = nil) -> some View`
  - **Empty State Handling**: Automatically displays intelligent empty state when items array is empty
  - **Context-Aware Messaging**: Empty state messages adapt based on data type, context, and complexity hints
  - **Create Action Support**: Optional create action parameter for actionable empty states with data-type-specific button labels
- `platformPresentFormData_L1(fields: [GenericFormField], hints: PresentationHints) -> some View`
- `platformPresentNumericData_L1(data: [GenericNumericData], hints: PresentationHints) -> some View`
- `platformResponsiveCard_L1<Content: View>(@ViewBuilder content: () -> Content, hints: PresentationHints) -> some View`
- `platformPresentMediaData_L1(media: [GenericMediaItem], hints: PresentationHints) -> some View`
- `platformPresentHierarchicalData_L1(items: [GenericHierarchicalItem], hints: PresentationHints) -> some View`
- `platformPresentTemporalData_L1(items: [GenericTemporalItem], hints: PresentationHints) -> some View`
- `platformPresentContent_L1(content: Any, hints: PresentationHints) -> some View`

### Enhanced Hints Overloads
- `platformPresentItemCollection_L1<Item: Identifiable>(items: [Item], hints: EnhancedPresentationHints, onCreateItem: (() -> Void)? = nil) -> some View`
- `platformPresentFormData_L1(fields: [GenericFormField], hints: EnhancedPresentationHints) -> some View`
- `platformPresentNumericData_L1(data: [GenericNumericData], hints: EnhancedPresentationHints) -> some View`
- `platformResponsiveCard_L1<Content: View>(@ViewBuilder content: () -> Content, hints: EnhancedPresentationHints) -> some View`
- `platformPresentMediaData_L1(media: [GenericMediaItem], hints: EnhancedPresentationHints) -> some View`
- `platformPresentHierarchicalData_L1(items: [GenericHierarchicalItem], hints: EnhancedPresentationHints) -> some View`
- `platformPresentTemporalData_L1(items: [GenericTemporalItem], hints: EnhancedPresentationHints) -> some View`

### Empty State Components (PlatformSemanticLayer1.swift)
- `CollectionEmptyStateView(hints: PresentationHints, onCreateItem: (() -> Void)? = nil) -> some View`
  - **Intelligent Empty States**: Displays context-appropriate empty state messages
  - **Data Type Aware**: Icons and titles adapt based on DataTypeHint
  - **Context Sensitive**: Messages change based on PresentationContext
  - **Complexity Adaptive**: Guidance adjusts based on ContentComplexity
  - **Actionable Empty States**: Optional create action with data-type-specific button labels (e.g., "Add Media", "Add Event", "Add Product")

### Cross-Platform Optimization Layer 6 (CrossPlatformOptimizationLayer6.swift)
- `CrossPlatformOptimizationManager` class
- `PerformanceBenchmarking.benchmarkView<Content: View>(_ content: Content, benchmarkName: String, iterations: Int = 100) -> PerformanceBenchmark`
- `CrossPlatformTesting.testViewAcrossPlatforms<Content: View>(_ content: Content, testName: String) -> CrossPlatformTestResults`
- `PlatformUIPatterns` struct with navigationPatterns, interactionPatterns, layoutPatterns

### Data Types and Structures
- `PresentationHints` - Basic hints for guiding generic functions
- `EnhancedPresentationHints` - Extended hints with extensible business logic
- `DataTypeHint` - Enum for different data types (form, collection, media, etc.)
- `PresentationPreference` - Enum for presentation preferences (automatic, modal, etc.)
- `PresentationContext` - Enum for presentation context (dashboard, detail, etc.)
- `ContentComplexity` - Enum for content complexity levels
- `CustomHint` - Protocol for extensible business-specific hints
- `Platform` - Enum for supported platforms (iOS, macOS, watchOS, tvOS, visionOS)

### Performance and Testing Types
- `PerformanceBenchmark` - Results of performance benchmarking
- `CrossPlatformTestResults` - Results of cross-platform testing
- `PlatformBenchmarkResult` - Platform-specific benchmark results
- `TestResult` - Individual platform test results
- `PerformanceMetrics` - Performance measurement data
- `MemoryMetrics` - Memory usage metrics
Implementation Strategy
Phase 1: Foundation (COMPLETED ✅)
Implemented Level 1, 2, 3, 4, 5, and 6 with layer-numbered naming convention
Established clean delegation chain: Level 1 → Level 2 → Level 3 → Level 4 → Level 5 → Level 6
All functions now use layer-numbered naming (e.g., `_L1`, `_L2`, `_L3`, `_L4`, `_L5`, `_L6`)
Eliminated naming conflicts and improved architectural clarity
Phase 2: Gradual Enhancement
Enhance Level 2 with basic content analysis (field count, screen size)
Add performance optimizations when working on performance
Add responsive logic when working on responsive design
Add accessibility enhancements when working on accessibility
Phase 3: Intelligent Layout
Content-aware layout strategy decisions
Performance profiling and optimization
User preference learning
Platform-specific enhancement
Phase 4: Unified Interface
Merge stub functions into unified platformPresent() function
Full data-driven presentation intelligence
Advanced optimization algorithms
Migration Strategy
Gradual Migration Path
Views can migrate one at a time to new semantic functions
Old Level 3 calls continue to work during migration
New views use semantic functions from the start
Easy rollback if issues arise
Migration Examples
Current (Level 3 direct):
var body: some View {
platformVStackContainer {
Text("Content")
}
}
New (Level 1 semantic):
var body: some View {
platformVerticalStack { // ← Delegates to Level 2 → Level 3
Text("Content")
}
}
Files to Migrate
AddExpenseView: platformVStackContainer → platformVerticalStack
AddMaintenanceRecordView: platformVStackContainer → platformVerticalStack
AddVehicleView: platformVStackContainer → platformVerticalStack
Grid-based views: platformGridContainer → platformGridStack
Form views: platformFormContainer → platformFormStack
File Structure
Current Implementation (COMPLETED ✅)
Shared/Views/Extensions/
├── PlatformSemanticLayer1.swift # Level 1: Semantic functions with _L1 naming
├── PlatformLayoutDecisionLayer2.swift # Level 2: Layout decision engine with _L2 naming
├── PlatformStrategySelectionLayer3.swift # Level 3: Strategy selection with _L3 naming
├── PlatformSpecificViewExtensions.swift # Level 4: Component implementation with _L4 naming
├── PlatformIOSOptimizationsLayer5.swift # Level 5: iOS optimizations with _L5 naming
└── PlatformStylingLayer4.swift # Level 4: Styling components with _L4 naming

Additional Files:
├── PlatformNavigationLayer4.swift # Level 4: Navigation components with _L4 naming
├── PlatformModalsLayer4.swift # Level 4: Modal components with _L4 naming
└── ResponsiveCardsView.swift # Demo implementation using all layers
Technical Implementation
Level 1: Semantic Functions (IMPLEMENTED ✅)
// PlatformSemanticLayer1.swift
func platformResponsiveCard_L1<Content: View>(
    type: CardType,
    content: @escaping () -> Content
) -> some View {
    return ResponsiveCardContainer(type: type, content: content)
}

func platformPresentItemCollection_L1<Item: Identifiable>(
    items: [Item],
    hints: PresentationHints
) -> some View {
    return GenericItemCollectionView(items: items, hints: hints)
}

Level 2: Layout Decision Engine (IMPLEMENTED ✅)
// PlatformLayoutDecisionLayer2.swift
func determineOptimalCardLayout_L2(
    cardCount: Int,
    screenWidth: CGFloat,
    screenHeight: CGFloat,
    deviceType: DeviceType
) -> CardLayoutDecision {
    // Analyzes content and device capabilities to make layout decisions
    let complexity = assessCardCountComplexity(cardCount)
    let strategy = chooseCardStrategy(cardCount: cardCount, complexity: complexity, capabilities: DeviceCapabilities())
    return CardLayoutDecision(strategy: strategy, columns: columns, spacing: spacing, responsive: responsive, performance: performance)
}
func determineOptimalGridLayout<Content: View>(
content: Content,
context: LayoutContext = .default
) -> some View {
// No-Op for now: always choose Grid
// Future: analyze content and choose optimal grid configuration
return platformGridContainer(content: { content })
}
Level 3: Layout Implementation (Already Working)
// Existing functions - no changes needed initially
// platformVStackContainer, platformGridContainer, platformLazyVStackContainer
// These are already implemented and working
Level 4: Technical Implementation (Future)
// PlatformTechnicalExtensions.swift
func platformVStackImplementation<Content: View>(
alignment: HorizontalAlignment = .center,
spacing: CGFloat? = nil,
@ViewBuilder content: () -> Content
) -> some View {
// Clean technical implementation without platform-specific styling
VStack(alignment: alignment, spacing: spacing) {
content()
}
// Delegate to Level 5 for platform-specific styling
return platformVStackStyling()
}
Level 5: Platform Optimization (Future)
// PlatformOptimizationExtensions.swift
func platformVStackStyling<Content: View>(
@ViewBuilder content: () -> Content
) -> some View {
#if os(iOS)
return content()
.padding(16)
.background(Color(UIColor.systemGroupedBackground))
.cornerRadius(12)
#elseif os(macOS)
return content()
.padding(20)
.background(Color(NSColor.controlBackgroundColor))
.cornerRadius(8)
#endif
}
Content Analysis Integration
FormContentMetrics Integration
Use existing FormContentMetrics system for content analysis
Extend with additional analysis capabilities
Provide data to Level 2 decision engine
Content Analysis Features
Field count analysis (forms with >8 fields get LazyVStack)
Content density analysis (dense content gets Grid layout)
Accessibility analysis (high accessibility needs influence layout choice)
Performance analysis (large content gets optimized layouts)
Layout Context
Screen size and orientation
Platform capabilities
User preferences
Accessibility needs
Performance constraints
Testing Strategy
Phase 1 Testing
Verify identical output between new and existing functions
Test delegation chain: Level 1 → Level 2 → Level 3 → Level 4 → Level 5
Ensure zero functional regression
Phase 2 Testing
Test enhanced Level 2 intelligence
Validate content analysis and layout decisions
Performance benchmarking
Phase 3 Testing
Test unified platformPresent function
Validate data-driven layout selection
Platform-specific optimization testing
Documentation Requirements
Architecture Documentation
Five-layer system overview
Delegation chain diagrams
Migration strategy and timeline
Best practices and guidelines
Developer Documentation
Migration guide for existing views
Examples of new semantic functions
Performance optimization guidelines
Troubleshooting guide
Future Enhancement Roadmap
Content analysis capabilities
Performance optimization features
Platform-specific enhancements
User preference learning
Success Criteria
Phase 1 Success
[ ] Five-layer architecture established
[ ] Stub functions produce identical output
[ ] Clean delegation chain working
[ ] Zero functional regression
[ ] Views can migrate gradually
Phase 2 Success
[ ] Level 2 intelligence enhanced
[ ] Content analysis working
[ ] Performance optimizations implemented
[ ] Responsive design improvements
[ ] Accessibility enhancements
Phase 3 Success
[ ] Unified platformPresent function
[ ] Data-driven layout selection
[ ] Advanced optimization algorithms
[ ] User preference learning
[ ] Platform-specific optimization
Future Vision
Ultimate Goal
Views provide data and hints, and the system automatically:
Analyzes content and context
Chooses optimal layout strategy
Implements with platform-specific optimizations
Learns from user interactions
Continuously improves performance
Benefits
100% platform-independent UI code
Intelligent, adaptive layouts
Performance optimization per platform
Accessibility enhancement per platform
User preference learning
Future-proof architecture
Task Creation Instructions
When creating tasks in the MCP Shrimp Task Manager:
Use the main task description as the primary task
Break down into subtasks for each phase
Set priority as Medium (after current project stability)
Include all technical details from this document
Reference the pinned architectural insights
Set dependencies between phases
Include file paths and implementation details
Set acceptance criteria for each phase
This document contains all the information needed to create comprehensive tasks for the five-layer UI abstraction architecture implementation.