import Foundation
import SwiftUI

// MARK: - Enhanced Debug Entry

/// Enhanced debug entry with view hierarchy and screen context for UI testing
public struct AccessibilityDebugEntry {
    public let id: String
    public let context: String
    public let timestamp: Date
    public let viewHierarchy: [String]
    public let screenContext: String?
    public let navigationState: String?
    
    public init(id: String, context: String, timestamp: Date, viewHierarchy: [String], screenContext: String? = nil, navigationState: String? = nil) {
        self.id = id
        self.context = context
        self.timestamp = timestamp
        self.viewHierarchy = viewHierarchy
        self.screenContext = screenContext
        self.navigationState = navigationState
    }
}

// MARK: - Accessibility Identifier Configuration

/// Global configuration for automatic accessibility identifier generation
@MainActor
public class AccessibilityIdentifierConfig: ObservableObject {
    
    // MARK: - Singleton
    
    public static let shared = AccessibilityIdentifierConfig()
    
    // MARK: - Published Properties
    
    /// Whether automatic accessibility identifiers are enabled
    @Published public var enableAutoIDs: Bool = true
    
    /// Global namespace for generated identifiers
    @Published public var namespace: String = "app"
    
    /// Generation mode for identifiers
    @Published public var mode: AccessibilityIdentifierMode = .automatic
    
    /// Whether to enable DEBUG collision detection
    @Published public var enableCollisionDetection: Bool = true
    
    /// Whether to enable DEBUG logging of generated IDs
    @Published public var enableDebugLogging: Bool = false
    
    /// Whether to enable enhanced debugging with view hierarchy tracking
    @Published public var enableViewHierarchyTracking: Bool = false
    
    /// Whether to enable UI test integration features
    @Published public var enableUITestIntegration: Bool = false
    
    // MARK: - Private Properties
    
    private var generatedIDs: Set<String> = []
    
    /// DEBUG: Log of all generated IDs with context
    public var generatedIDsLog: [(id: String, context: String, timestamp: Date)] = []
    
    /// DEBUG: Enhanced log entries with view hierarchy and screen context
    public var enhancedDebugLog: [AccessibilityDebugEntry] = []
    
    /// Current view hierarchy for breadcrumb tracking
    public var currentViewHierarchy: [String] = []
    
    /// Current screen context for breadcrumb tracking
    public var currentScreenContext: String?
    
    /// Current navigation state for breadcrumb tracking
    public var currentNavigationState: String?
    
    // MARK: - Initialization
    
    private init() {
        // Private initializer for singleton
    }
    
    // MARK: - Public Methods
    
    /// Reset configuration to defaults
    public func resetToDefaults() {
        enableAutoIDs = true
        namespace = "app"
        mode = .automatic
        enableCollisionDetection = true
        enableDebugLogging = false
        enableViewHierarchyTracking = false
        enableUITestIntegration = false
        generatedIDs.removeAll()
        generatedIDsLog.removeAll()
        enhancedDebugLog.removeAll()
        currentViewHierarchy.removeAll()
        currentScreenContext = nil
        currentNavigationState = nil
    }
    
    /// Check if an ID has been generated before (collision detection)
    public func checkForCollision(_ id: String) -> Bool {
        guard enableCollisionDetection else { return false }
        // Only report collision if the ID was generated by a different object/context
        // For now, we'll just check if it exists - in a more sophisticated implementation
        // we could track the source of each ID to detect actual conflicts
        return generatedIDs.contains(id)
    }
    
    /// Register a generated ID for collision detection
    public func registerGeneratedID(_ id: String) {
        guard enableCollisionDetection else { return }
        generatedIDs.insert(id)
    }
    
    /// Clear all registered IDs (useful for testing)
    public func clearRegisteredIDs() {
        generatedIDs.removeAll()
    }
    
    // MARK: - DEBUG Methods
    
    /// Log a generated ID with context for debugging
    public func logGeneratedID(_ id: String, context: String) {
        guard enableDebugLogging else { return }
        
        let logEntry = (id: id, context: context, timestamp: Date())
        generatedIDsLog.append(logEntry)
        
        // Enhanced logging with view hierarchy and screen context
        if enableViewHierarchyTracking || enableUITestIntegration {
            let enhancedEntry = AccessibilityDebugEntry(
                id: id,
                context: context,
                timestamp: Date(),
                viewHierarchy: currentViewHierarchy,
                screenContext: currentScreenContext,
                navigationState: currentNavigationState
            )
            enhancedDebugLog.append(enhancedEntry)
        }
        
        #if DEBUG
        print("üîç Accessibility ID Generated: '\(id)' for \(context)")
        if enableViewHierarchyTracking && !currentViewHierarchy.isEmpty {
            print("   üìç View Hierarchy: \(currentViewHierarchy.joined(separator: " ‚Üí "))")
        }
        if let screen = currentScreenContext {
            print("   üì± Screen: \(screen)")
        }
        if let navState = currentNavigationState {
            print("   üß≠ Navigation: \(navState)")
        }
        #endif
    }
    
    /// Get all generated IDs as a formatted string for debugging
    public func getDebugLog() -> String {
        guard !generatedIDsLog.isEmpty else {
            return "No accessibility identifiers generated yet."
        }
        
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm:ss.SSS"
        
        let logEntries = generatedIDsLog.map { entry in
            "\(formatter.string(from: entry.timestamp)) - \(entry.id) (\(entry.context))"
        }
        
        return "Generated Accessibility Identifiers:\n" + logEntries.joined(separator: "\n")
    }
    
    /// Print debug log to console
    public func printDebugLog() {
        print(getDebugLog())
    }
    
    /// Clear debug log
    public func clearDebugLog() {
        generatedIDsLog.removeAll()
        enhancedDebugLog.removeAll()
        currentViewHierarchy.removeAll()
        currentScreenContext = nil
        currentNavigationState = nil
    }
    
    // MARK: - View Hierarchy Management
    
    /// Push a view name onto the current view hierarchy
    public func pushViewHierarchy(_ viewName: String) {
        currentViewHierarchy.append(viewName)
    }
    
    /// Pop the last view name from the current view hierarchy
    public func popViewHierarchy() {
        if !currentViewHierarchy.isEmpty {
            currentViewHierarchy.removeLast()
        }
    }
    
    /// Check if the current view hierarchy is empty
    public func isViewHierarchyEmpty() -> Bool {
        return currentViewHierarchy.isEmpty
    }
    
    /// Set the current screen context for breadcrumb tracking
    public func setScreenContext(_ screen: String) {
        currentScreenContext = screen
    }
    
    /// Set the current navigation state for breadcrumb tracking
    public func setNavigationState(_ state: String) {
        currentNavigationState = state
    }
    
    // MARK: - UI Test Integration
    
    /// Generate UI test code from the enhanced debug log
    public func generateUITestCode() -> String {
        guard !enhancedDebugLog.isEmpty else {
            return "// No accessibility identifiers generated yet"
        }
        
        var testCode = "// Generated UI Test Code\n"
        testCode += "// Generated at: \(Date())\n\n"
        
        // Group by screen context
        let groupedByScreen = Dictionary(grouping: enhancedDebugLog) { $0.screenContext ?? "Unknown" }
        
        for (screen, entries) in groupedByScreen.sorted(by: { $0.key < $1.key }) {
            testCode += "// Screen: \(screen)\n"
            for entry in entries.sorted(by: { $0.timestamp < $1.timestamp }) {
                let testMethod = generateTestMethod(for: entry)
                testCode += testMethod + "\n"
            }
            testCode += "\n"
        }
        
        return testCode
    }
    
    private func generateTestMethod(for entry: AccessibilityDebugEntry) -> String {
        let methodName = entry.id.replacingOccurrences(of: ".", with: "_").replacingOccurrences(of: "-", with: "_")
        let hierarchy = entry.viewHierarchy.isEmpty ? "" : " // Hierarchy: \(entry.viewHierarchy.joined(separator: " ‚Üí "))"
        
        return """
        func test_\(methodName)() {
            let element = app.otherElements["\(entry.id)"]
            XCTAssertTrue(element.exists, "Element '\(entry.id)' should exist")\(hierarchy)
        }
        """
    }
    
    /// Generate breadcrumb trail from enhanced debug log
    public func generateBreadcrumbTrail() -> String {
        guard !enhancedDebugLog.isEmpty else {
            return "No accessibility identifiers generated yet."
        }
        
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm:ss.SSS"
        
        var breadcrumb = "üçû Accessibility ID Breadcrumb Trail:\n\n"
        
        // Group by screen context
        let groupedByScreen = Dictionary(grouping: enhancedDebugLog) { $0.screenContext ?? "Unknown" }
        
        for (screen, entries) in groupedByScreen.sorted(by: { $0.key < $1.key }) {
            breadcrumb += "üì± Screen: \(screen)\n"
            
            for entry in entries.sorted(by: { $0.timestamp < $1.timestamp }) {
                breadcrumb += "  \(formatter.string(from: entry.timestamp)) - \(entry.id)\n"
                
                if !entry.viewHierarchy.isEmpty {
                    breadcrumb += "    üìç Path: \(entry.viewHierarchy.joined(separator: " ‚Üí "))\n"
                }
                
                if let navState = entry.navigationState {
                    breadcrumb += "    üß≠ Navigation: \(navState)\n"
                }
            }
            breadcrumb += "\n"
        }
        
        return breadcrumb
    }
    
    /// Print UI test code to console
    public func printUITestCode() {
        print(generateUITestCode())
    }
    
    /// Generate UI test code and save to file in autoGeneratedTests folder
    public func generateUITestCodeToFile() throws -> String {
        let testCode = generateUITestCode()
        
        // Create autoGeneratedTests directory if it doesn't exist
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        let autoGeneratedTestsPath = documentsPath.appendingPathComponent("autoGeneratedTests")
        
        try FileManager.default.createDirectory(at: autoGeneratedTestsPath, withIntermediateDirectories: true, attributes: nil)
        
        // Generate unique filename with PID and timestamp
        let pid = ProcessInfo.processInfo.processIdentifier
        let timestamp = Int(Date().timeIntervalSince1970)
        let filename = "GeneratedUITests_\(pid)_\(timestamp).swift"
        let filePath = autoGeneratedTestsPath.appendingPathComponent(filename)
        
        // Write test code to file
        try testCode.write(to: filePath, atomically: true, encoding: .utf8)
        
        return filePath.path
    }
    
    /// Generate UI test code and copy to clipboard (macOS only)
    public func generateUITestCodeToClipboard() {
        let testCode = generateUITestCode()
        #if os(macOS)
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(testCode, forType: .string)
        #endif
    }
    
    /// Print breadcrumb trail to console
    public func printBreadcrumbTrail() {
        print(generateBreadcrumbTrail())
    }
    
    // MARK: - UI Test Helpers
    
    /// Get XCTest element reference for an accessibility ID
    public func getElementByID(_ id: String) -> String {
        return "app.otherElements[\"\(id)\"]"
    }
    
    /// Generate tap action code for UI testing
    public func generateTapAction(_ id: String) -> String {
        return """
        let element = app.otherElements["\(id)"]
        XCTAssertTrue(element.exists, "Element '\(id)' should exist")
        element.tap()
        """
    }
    
    /// Generate text input action code for UI testing
    public func generateTextInputAction(_ id: String, text: String) -> String {
        return """
        let element = app.textFields["\(id)"]
        XCTAssertTrue(element.exists, "Text field '\(id)' should exist")
        element.tap()
        element.typeText("\(text)")
        """
    }
}

// MARK: - Accessibility Identifier Mode

/// Generation mode for accessibility identifiers
public enum AccessibilityIdentifierMode: String, CaseIterable {
    case automatic = "automatic"
    case semantic = "semantic"
    case minimal = "minimal"
    
    public var description: String {
        switch self {
        case .automatic:
            return "Full automatic generation with namespace, context, role, and object identity"
        case .semantic:
            return "Semantic generation focusing on meaningful identifiers"
        case .minimal:
            return "Minimal generation with basic object identity only"
        }
    }
}

// MARK: - Accessibility Identifier Generator

/// Generates deterministic accessibility identifiers based on object identity and context
@MainActor
public struct AccessibilityIdentifierGenerator {
    
    // MARK: - Public Methods
    
    /// Generate an accessibility identifier for an Identifiable object
    public func generateID<T: Identifiable>(
        for object: T,
        role: String,
        context: String
    ) -> String {
        let config = AccessibilityIdentifierConfig.shared
        
        guard config.enableAutoIDs else {
            return ""
        }
        
        let identifier = buildIdentifier(
            namespace: config.namespace,
            context: context,
            role: role,
            objectID: String(describing: object.id)
        )
        
        // Register for collision detection
        config.registerGeneratedID(identifier)
        
        // Log for debugging
        config.logGeneratedID(identifier, context: "Identifiable(\(String(describing: object.id)))")
        
        return identifier
    }
    
    /// Generate an accessibility identifier for a non-Identifiable object
    public func generateID(
        for object: Any,
        role: String,
        context: String
    ) -> String {
        let config = AccessibilityIdentifierConfig.shared
        
        guard config.enableAutoIDs else {
            return ""
        }
        
        let objectID = generateObjectID(for: object)
        let identifier = buildIdentifier(
            namespace: config.namespace,
            context: context,
            role: role,
            objectID: objectID
        )
        
        // Register for collision detection
        config.registerGeneratedID(identifier)
        
        // Log for debugging
        config.logGeneratedID(identifier, context: "Any(\(String(describing: type(of: object))))")
        
        return identifier
    }
    
    /// Check if an identifier would cause a collision
    public func checkForCollision(_ identifier: String) -> Bool {
        return AccessibilityIdentifierConfig.shared.checkForCollision(identifier)
    }
    
    // MARK: - Private Methods
    
    private func buildIdentifier(
        namespace: String,
        context: String,
        role: String,
        objectID: String
    ) -> String {
        let config = AccessibilityIdentifierConfig.shared
        
        switch config.mode {
        case .automatic:
            return "\(namespace).\(context).\(role).\(objectID)"
        case .semantic:
            return "\(namespace).\(role).\(objectID)"
        case .minimal:
            return "\(objectID)"
        }
    }
    
    private func generateObjectID(for object: Any) -> String {
        // Try to extract meaningful identifier from object
        if let string = object as? String {
            return sanitizeID(string)
        } else if let number = object as? NSNumber {
            return "\(number)"
        } else if let array = object as? [Any], !array.isEmpty {
            return "array-\(array.count)"
        } else if let dict = object as? [String: Any], !dict.isEmpty {
            return "dict-\(dict.count)"
        } else {
            // Fallback to type name and hash
            let typeName = String(describing: type(of: object))
            let hash = abs(ObjectIdentifier(object as AnyObject).hashValue)
            return "\(typeName)-\(hash)"
        }
    }
    
    private func sanitizeID(_ id: String) -> String {
        // Remove or replace characters that might cause issues in accessibility identifiers
        return id
            .replacingOccurrences(of: " ", with: "-")
            .replacingOccurrences(of: ".", with: "-")
            .replacingOccurrences(of: "/", with: "-")
            .replacingOccurrences(of: "\\", with: "-")
            .replacingOccurrences(of: ":", with: "-")
            .replacingOccurrences(of: ";", with: "-")
            .replacingOccurrences(of: ",", with: "-")
            .lowercased()
    }
}

// MARK: - View Extensions

public extension View {
    
    /// Apply automatic accessibility identifiers to this view
    func automaticAccessibilityIdentifiers() -> some View {
        self.modifier(AutomaticAccessibilityIdentifierModifier())
    }
    
    /// Disable automatic accessibility identifiers for this specific view
    func disableAutomaticAccessibilityIdentifiers() -> some View {
        self.modifier(DisableAutomaticAccessibilityIdentifierModifier())
    }
    
    /// Apply automatic accessibility identifiers globally to all views in this hierarchy
    /// This should be called once at the app level (e.g., in your main App struct)
    func enableGlobalAutomaticAccessibilityIdentifiers() -> some View {
        self.modifier(GlobalAutomaticAccessibilityIdentifierModifier())
    }
}

// MARK: - Automatic Accessibility Identifier Modifier

/// Modifier that automatically applies accessibility identifiers to views
public struct AutomaticAccessibilityIdentifierModifier: ViewModifier {
    
    public func body(content: Content) -> some View {
        content
            .modifier(AccessibilityIdentifierAssignmentModifier())
    }
}

/// Global modifier that automatically applies accessibility identifiers to all views
/// This should be applied once at the app level
public struct GlobalAutomaticAccessibilityIdentifierModifier: ViewModifier {
    
    public func body(content: Content) -> some View {
        content
            .modifier(AccessibilityIdentifierAssignmentModifier())
    }
}

// MARK: - Disable Automatic Accessibility Identifier Modifier

/// Modifier that disables automatic accessibility identifiers for a specific view
public struct DisableAutomaticAccessibilityIdentifierModifier: ViewModifier {
    
    public func body(content: Content) -> some View {
        content
            .environment(\.disableAutomaticAccessibilityIdentifiers, true)
    }
}

// MARK: - Accessibility Identifier Assignment Modifier

/// Internal modifier that handles the actual ID assignment
@MainActor
public struct AccessibilityIdentifierAssignmentModifier: ViewModifier {
    
    @Environment(\.disableAutomaticAccessibilityIdentifiers) private var disableAutoIDs
    @Environment(\.globalAutomaticAccessibilityIdentifiers) private var globalAutoIDs
    
    public func body(content: Content) -> some View {
        let config = AccessibilityIdentifierConfig.shared
        let shouldApplyAutoIDs = !disableAutoIDs && config.enableAutoIDs
        
        if shouldApplyAutoIDs {
            // Apply automatic identifier based on view context
            content
                .accessibilityIdentifier(generateAutomaticID())
        } else {
            content
        }
    }
    
    private func generateAutomaticID() -> String {
        let generator = AccessibilityIdentifierGenerator()
        let config = AccessibilityIdentifierConfig.shared
        
        // Use view hierarchy context if available
        let context = config.currentViewHierarchy.isEmpty ? "ui" : config.currentViewHierarchy.joined(separator: ".")
        let screenContext = config.currentScreenContext ?? "main"
        let role = "element"
        
        // Generate a unique object ID based on view type and hierarchy
        let objectID = generateViewObjectID(context: context, screenContext: screenContext)
        
        let id = generator.generateID(
            for: objectID,
            role: role,
            context: screenContext
        )
        
        // Additional logging for view-level assignment
        config.logGeneratedID(id, context: "ViewModifier(\(context))")
        
        return id
    }
    
    private func generateViewObjectID(context: String, screenContext: String) -> String {
        // Create a more meaningful object ID based on context
        let timestamp = Int(Date().timeIntervalSince1970 * 1000) % 10000 // Last 4 digits of timestamp
        let contextHash = abs(context.hashValue) % 1000 // Last 3 digits of context hash
        
        return "\(screenContext.lowercased())-\(context.lowercased())-\(timestamp)-\(contextHash)"
    }
}

// MARK: - Environment Keys

/// Environment key for disabling automatic accessibility identifiers
public struct DisableAutomaticAccessibilityIdentifiersKey: EnvironmentKey {
    public static let defaultValue: Bool = false
}

/// Environment key for enabling global automatic accessibility identifiers
public struct GlobalAutomaticAccessibilityIdentifiersKey: EnvironmentKey {
    public static let defaultValue: Bool = false
}

public extension EnvironmentValues {
    var disableAutomaticAccessibilityIdentifiers: Bool {
        get { self[DisableAutomaticAccessibilityIdentifiersKey.self] }
        set { self[DisableAutomaticAccessibilityIdentifiersKey.self] = newValue }
    }
    
    var globalAutomaticAccessibilityIdentifiers: Bool {
        get { self[GlobalAutomaticAccessibilityIdentifiersKey.self] }
        set { self[GlobalAutomaticAccessibilityIdentifiersKey.self] = newValue }
    }
}

// MARK: - View Hierarchy Tracking Modifiers

/// View modifier for tracking view hierarchy in breadcrumb system
public struct ViewHierarchyTrackingModifier: ViewModifier {
    let viewName: String
    
    public func body(content: Content) -> some View {
        content
            .onAppear {
                AccessibilityIdentifierConfig.shared.pushViewHierarchy(viewName)
            }
            .onDisappear {
                AccessibilityIdentifierConfig.shared.popViewHierarchy()
            }
            .automaticAccessibilityIdentifiers() // Automatically apply accessibility identifiers
    }
}

/// View modifier for setting screen context in breadcrumb system
public struct ScreenContextModifier: ViewModifier {
    let screenName: String
    
    public func body(content: Content) -> some View {
        content
            .onAppear {
                AccessibilityIdentifierConfig.shared.setScreenContext(screenName)
            }
            .automaticAccessibilityIdentifiers() // Automatically apply accessibility identifiers
    }
}

/// View modifier for setting navigation state in breadcrumb system
public struct NavigationStateModifier: ViewModifier {
    let navigationState: String
    
    public func body(content: Content) -> some View {
        content
            .onAppear {
                AccessibilityIdentifierConfig.shared.setNavigationState(navigationState)
            }
            .automaticAccessibilityIdentifiers() // Automatically apply accessibility identifiers
    }
}

// MARK: - View Extensions for Breadcrumb Tracking

public extension View {
    /// Track this view in the hierarchy for breadcrumb debugging
    /// - Parameter name: The name to use for this view in the hierarchy
    /// - Returns: A view that tracks its presence in the view hierarchy
    func trackViewHierarchy(_ name: String) -> some View {
        modifier(ViewHierarchyTrackingModifier(viewName: name))
    }
    
    /// Set the screen context for breadcrumb debugging
    /// - Parameter name: The screen name to use for breadcrumb grouping
    /// - Returns: A view that sets the screen context
    func screenContext(_ name: String) -> some View {
        modifier(ScreenContextModifier(screenName: name))
    }
    
    /// Set the navigation state for breadcrumb debugging
    /// - Parameter state: The navigation state to track
    /// - Returns: A view that sets the navigation state
    func navigationState(_ state: String) -> some View {
        modifier(NavigationStateModifier(navigationState: state))
    }
}
